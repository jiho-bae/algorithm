/*
    2N명의 사람 -> N명씩 2개 팀으로 숫자게임. A / B팀
    모든사람 -> 무작위 자연수 1개씩
    사람 -> 한번씩만 경기
    A와 B 한명씩 숫자를 공개, 숫자가 큰 팀이 승점1점.
    - 숫자가 같으면 승점x
    
    A가 빠르게 순서 정해서 리스트 공개해버림.
    B가 이걸 보고 어떻게 승점 최대화 시킬 수 있나?
    
    1 <= A, B.length <= 10만
    1 <= A, B element <= 10억
    
    A = 5137, B=2268일 때..
    B = 6228
    8264였어봐. 그럼 6248이어야함.
    
    이것도 그리디하게 풀어야할 것 같은데...
    문제는.. B가 10억까지도 될 수 있는 것. 배열로는 안된다.
    !!어떻게하든 그냥 이기면 되나? -> B가 최대한 작은 점수차로 이겨야한다.!!
    
    그럼 A 배열을 그대로 둬야하나?
    어차피 순서는 정해진거니까, 그냥 오름차순/내림차순 정렬해버려도 상관이 없다.

    그럼 A,B를 우선 오름차순 정렬하고.
    각 인덱스를 비교...? -> x. 오류난다. 
    
    투포인터 느낌으로 가보자.
    B의 맨 뒤 인덱스부터 줄여나가면서, 바로 삭제할 수 있는 A가 있나 확인한다.
    삭제가 가능하면 B, A의 인덱스를 각각 -1한다.
    삭제가 불가능하면 더 작은 A를 찾아야 하므로 A의 인덱스만 -1한다.
    B나 A의 인덱스가 -1이면 탐색을 중지하고 출력한다.
    
*/

function solution(A, B) {
  const len = A.length;
  let answer = 0;
  let idxA = len - 1;
  let idxB = len - 1;

  A.sort((a, b) => a - b);
  B.sort((a, b) => a - b);

  while (idxA !== -1 && idxB !== -1) {
    if (B[idxB] > A[idxA]) {
      answer++;
      idxB--;
    }
    idxA--;
  }

  return answer;
}
